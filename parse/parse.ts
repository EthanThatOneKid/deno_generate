import type { Reader } from "../deps.ts";
import { readLines } from "../deps.ts";
import { quotedSplit } from "./quoted_split.ts";

/**
 * ParsedComment is a command that is generated by a //deno:generate
 * comment.
 */
export interface ParsedComment {
  args: string[];
  original: string;
  line: bigint;
  character: bigint;
  alias?: string;
}

/**
 * DIRECTIVE_PATTERN is the pattern that matches a //deno:generate comment.
 */
export const DIRECTIVE_PATTERN = /^\/\/deno:generate\s+/;

/**
 * This is a very simple parser that only looks for comments
 * because to run arbitrary code generation commands, we only
 * need to parse the file to determine the comments. With each
 * comment, we return the line and character of the comment so that
 * we can tell the user where errors are.
 *
 * Implements dynamic programming to get the line and character of the comment.
 */
export async function parseComments(reader: Reader): Promise<ParsedComment[]> {
  const comments: ParsedComment[] = [];
  let currentLine = BigInt(0);
  for await (const line of readLines(reader)) {
    currentLine += BigInt(1);
    if (!DIRECTIVE_PATTERN.test(line)) {
      continue;
    }

    comments.push(
      fromComment(line, currentLine.valueOf(), BigInt(0)),
    );
  }

  return comments;
}

/**
 * Example commands all parse to the same thing:
 * //deno:generate echo "Hello World!"
 */
function fromComment(
  comment: string,
  line: bigint,
  character: bigint,
): ParsedComment {
  // Remove the leading // and trailing whitespace
  const original = comment
    .replace(DIRECTIVE_PATTERN, "")
    .trim();

  // Split on spaces, but not spaces inside quotes.
  const args = quotedSplit(original);

  // If the first arg is an alias, then we need to remove it from the
  // command and return it separately.
  if (args[0] === "-command") {
    return { args: args.slice(2), alias: args[1], line, character, original };
  }

  return { args, line, character, original };
}
