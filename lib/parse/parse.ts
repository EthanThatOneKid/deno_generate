import { quotedSplit } from "./quoted_split.ts";
import type { CharacterLocation } from "./re.ts";
import { getMatches } from "./re.ts";

/**
 * ParsedComment is a command that is generated by a //deno:generate
 * comment.
 */
export interface ParsedComment extends CharacterLocation {
  args: string[];
  original: string;
  alias?: string;
}

const MULTILINE_COMMAND_PATTERN =
  /\/\/deno:generate(.*?)(\\\s*(\r\n|[\r\n])(.*?)*\/\/(.*?))*(\r\n|[\r\n]|$)/gm;

/**
 * This is a very simple parser that only looks for comments
 * because to run arbitrary code generation commands, we only
 * need to parse the file to determine the comments. With each
 * comment, we return the line and character of the comment so that
 * we can tell the user where errors are.
 *
 * Implements dynamic programming to get the line and character of the comment.
 */
export function parseComments(content: string): ParsedComment[] {
  const cmds: ParsedComment[] = [];
  for (
    const { match, line, character } of getMatches(
      content,
      MULTILINE_COMMAND_PATTERN,
    )
  ) {
    cmds.push(fromComment(match, line, character));
  }
  return cmds;
}

/**
 * Example commands all parse to the same thing:
 * //deno:generate echo "Hello World!"
 *
 * //deno:generate echo \
 * //  "Hello World!"
 *
 * //deno:generate echo "Hello \
 * //World!"
 */
function fromComment(
  comment: string,
  line: number,
  character: number,
): ParsedComment {
  // Remove the leading // and trailing whitespace after line breaks
  // following a backslash. Also, remove the leading annotation, //deno:generate.
  const original = comment
    .replace(/^\/\/deno:generate\s+/, "")
    .replaceAll(/\s*\\\s*(\r\n|[\r\n])\s*\/\//gm, "")
    .trim();

  // Split on spaces, but not spaces inside quotes.
  const args = quotedSplit(original);

  // If the first arg is an alias, then we need to remove it from the
  // command and return it separately.
  if (args[0] === "-command") {
    return { args: args.slice(2), alias: args[1], line, character, original };
  }

  return { args, line, character, original };
}
